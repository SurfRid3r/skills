# 代码块控制字符模式分析

## 概述

本文档分析腾讯文档中代码块的控制字符模式，验证其是否为固定结构。

## 分析结论

**核心控制字符是固定的**，但内容中可能包含额外的内联格式标记（如用户提及、超链接、制表符等）。

---

## 三个 Case 的代码块结构对比

### 核心结构（固定）

| 位置 | Hex | 字符 | 含义 |
|------|-----|------|------|
| 开始 | `0x0f` | `\u000f` | CODE_BLOCK_START |
| 填充 | `0x1e × 5-6` | `\u001e` | RECORD_SEP (元数据槽位) |
| 行标记 | `0x1c` | `\u001c` | 语言标记/行分隔 |
| 行结束 | `0x0d 0x1d` | `\r\u001d` | 换行 + CODE_LINE_END |
| 结束 | `0x1e × N` | `\u001e` | 末尾填充 (可选) |

### Case 对比表

| 元素 | Case1 | Case2 (评论) | Case3 (评论) |
|------|-------|--------------|--------------|
| CODE_BLOCK_START (`0x0f`) | ✓ | ✓ | ✓ |
| RECORD_SEP 填充 (`0x1e`) | 6个 | 5个 | 5个 |
| 语言标记 (`0x1c`) | ✓ | ✓ | ✓ |
| 行结束 (`0x0d 0x1d`) | ✓ | ✓ | ✓ |
| 代码块行数 | 1 | 3 | 29 |
| 用户提及 (`0x13...0x14...0x15`) | 1 | 1 | 6 |
| 字面制表符 (`0x09`) | 0 | 10 | 46 |
| **注释**: Case2/Case3 的 `\x0f` 区域是评论内容，已通过 COMMENT_STORY_PROPERTY (108) 过滤 |

---

## 详细分析

### Case1 (单行代码块)

```
0x0f 0x1e×6 0x1c [内容] 0x0d 0x1d
```

- 内容: `this is code`
- 6个 RECORD_SEP 填充
- 1行代码
- `\u001c` 后无语言标识内容

### Case2 (多行代码块，3行)

```
0x0f 0x1e×5 0x1c [行1] 0x0d 0x1d 0x1c [行2] 0x0d 0x1d 0x1c [行3] 0x0d 0x1d 0x1e×2
```

- 每行以 `0x1c` 开始，以 `0x0d 0x1d` 结束
- 5个 RECORD_SEP 开头填充
- 末尾有2个 RECORD_SEP 填充
- 包含10个字面制表符

### Case3 (多行代码块，29行，含用户提及)

```
0x0f 0x1e×5 0x1c [内容] 0x0d 0x1d ... 0x1e×2
```

额外包含：
- **用户提及**: `0x13 MENTION_WXWORK [ID] 0x14 @用户名(ID) 0x15` (6处)
- **超链接**: `0x13 HYPERLINK [URL] 0x14 [显示文本] 0x15` (部分)
- **字面制表符**: `0x09` (46处，代码中的实际 tab)

---

## 控制字符完整列表

| Hex | 名称 | 用途 |
|-----|------|------|
| `0x0f` | CODE_BLOCK_START | 代码块开始 |
| `0x1d` | CODE_BLOCK_END | 代码块/行结束 |
| `0x1e` | RECORD_SEP | 元数据分隔符/填充 |
| `0x1c` | PICTURE_MARKER | 语言标记/行分隔 |
| `0x0d` | PARAGRAPH_SEP | 段落/行结束 |
| `0x13` | FIELD_BEGIN | 字段开始 (超链接/提及) |
| `0x14` | FIELD_SEPARATE | 字段分隔 (元数据/显示文本) |
| `0x15` | FIELD_END | 字段结束 |
| `0x09` | TAB | 字面制表符 |

---

## 代码块解析流程

```
1. 定位 0x0f (CODE_BLOCK_START)
2. 跳过连续的 0x1e (RECORD_SEP 开头填充)
3. 遍历每一行:
   - 检测 0x1c (行标记) 作为行开始
   - 读取内容直到 0x1d (行结束)
   - 过滤内容中的控制字符 (保留 0x09 TAB)
4. 检测连续的 0x1e 作为代码块结束标记
5. 合并所有行内容，用换行符分隔
```

---

## 内联格式处理

代码块内容中可能包含以下内联格式：

### 超链接格式
```
0x13 HYPERLINK [URL] 0x14 [显示文本] 0x15
```

### 用户提及格式
```
0x13 MENTION_WXWORK [ID1] [ID2] ... 0x14 @用户名(ID) 0x15
```

**处理方式**: 过滤控制字符 `0x13`, `0x14`, `0x15`，保留元数据和显示文本。

---

## 验证结论

1. **固定部分**: `0x0f` + `0x1e×N` + `0x1c` 作为代码块开头是固定的
2. **行结构**: 每行以 `0x1c` 开始，以 `0x0d 0x1d` 结束
3. **结束标记**: 连续的 `0x1e` 表示代码块结束
4. **可变部分**: 内容中可能包含超链接、用户提及和制表符

`_parse_code_block()` 的过滤逻辑 (ASCII < 32 且非 `\t`) 是正确的：
- 保留了字面制表符 `0x09`
- 过滤了所有控制字符标记
- 保留了元数据和显示文本

---

## RECORD_SEP 填充数量分析

RECORD_SEP (`0x1e`) 的数量在 5-6 之间变化，可能表示：
- 元数据槽位的数量
- 与代码块属性相关（如语言类型、行号显示等）

需要更多数据样本来确定具体规律。

---

## 修复记录

### 2026-02-14

修复了 `format_parser.py` 中的 `_parse_code_block()` 方法：
- **问题**: 原实现只读取到第一个 `0x1d`，导致多行代码块只解析第一行
- **修复**:
  - 跳过开头的 RECORD_SEP 填充
  - 按行解析 (以 `0x1c` 开始，`0x1d` 结束)
  - 检测连续的 RECORD_SEP 作为代码块结束标记
- **验证**: case1(1行)、case2(3行)、case3(29行) 均正确解析

### 2026-02-14 (评论过滤)

发现 Case2 和 Case3 的 `\x0f` 区域实际上是评论内容：
- **问题**: 评论内容使用与代码块相同的控制字符结构，被误解析为代码块
- **解决**:
  - 通过 `status_code=108` (COMMENT_STORY_PROPERTY) 识别评论区域
  - 在 `_parse_sections()` 中跳过评论区域
- **结果**: case2/case3 不再输出评论内容到 Markdown

---

*分析日期: 2026-02-14*
*数据来源: case1, case2, case3 intermediate.json*
